/* eslint-disable @typescript-eslint/no-shadow */
import { FastifyInstance } from 'fastify';
import { t, test } from 'tap';
import mongoose from 'mongoose';
import { appInstance } from 'test/app.instance';
import { LoginResponseDto, RegisterRequestDto } from '@/modules/auth/dtos/auth.dto';

let fastify: FastifyInstance;
let db: mongoose.mongo.Db;
let logger: FastifyInstance['log'];

const initiateTest = async () => {
  fastify = await appInstance();
  db = fastify.mongo;
  logger = fastify.log;
};

const testsCount = 2;
let testsDone = 0;

const clearDatabase = async () => {
  await db.collection('users').deleteMany({});
  await db.collection('auth').deleteMany({});
  await db.collection('urls').deleteMany({});
};

const executeTearDown = async () => {
  logger.info('Teardown: Removing all users from the database');
  await clearDatabase();
  fastify.close();
};

const checkForTearDown = async () => {
  testsDone += 1;
  if (testsDone === testsCount) {
    await executeTearDown();
  }
};

const mockUser: RegisterRequestDto = {
  email: 'mockuserurl@gmail.com',
  password: 'mockUserurl@123',
  username: 'MockUserurl'
};

const signupUser = async () => {
  const response = await fastify.inject({
    method: 'POST',
    url: '/auth/signup',
    payload: mockUser
  });
  t.equal(response.statusCode, 201);
};

const loginUser = async () => {
  const response = await fastify.inject({
    method: 'POST',
    url: '/auth/login',
    payload: {
      email: mockUser.email,
      password: mockUser.password
    }
  });
  return response;
};

t.before(async () => {
  await initiateTest();
  await clearDatabase();
  await signupUser();
});

test('URL ROUTER `/url`: Create Url', async () => {
  const testsCount = 6;
  let testsDone = 0;

  const callTearDown = async () => {
    await checkForTearDown();
  };

  const checkForCallTearDown = async () => {
    testsDone += 1;
    if (testsDone === testsCount) {
      await callTearDown();
    }
  };

  test('Success: create a new url without custom Alias', async (t1) => {
    logger.info('t1: Success: create a new url');

    const loginRes = await loginUser();
    t.equal(loginRes.statusCode, 200);

    const { idToken, user } = loginRes.json() as LoginResponseDto;

    const longUrl = 'https://www.google.com';

    const response = await fastify.inject({
      method: 'POST',
      url: '/url',
      headers: {
        token: idToken
      },
      payload: {
        url: longUrl
      }
    });

    t1.equal(response.statusCode, 201);

    const json = response.json();

    t1.equal(json.url, longUrl, 'The URL given by user');
    t1.ok(json.alias, 'The short URL generated by the system');
    t1.equal(json.clicks, 0, 'The number of clicks on the URL');
    t1.equal(json.customAlias, false, 'This field will return true if the user sets the custom alias');
    t1.equal(json.userId, user._id.toString(), 'The user ID of the user who created the URL');

    t1.end();
    await checkForCallTearDown();
  });

  test('Success: create a new url with custom Alias', async (t2) => {
    logger.info('t2: Success: create a new url with custom Alias');

    const loginRes = await loginUser();
    t2.equal(loginRes.statusCode, 200);

    const { idToken, user } = loginRes.json() as LoginResponseDto;

    const longUrl = 'https://www.google.com';
    const alias = 'google';

    const response = await fastify.inject({
      method: 'POST',
      url: '/url',
      headers: {
        token: idToken
      },
      payload: {
        url: longUrl,
        customAlias: alias
      }
    });

    t2.equal(response.statusCode, 201);

    const json = response.json();

    t2.equal(json.url, longUrl, 'The URL given by user');
    t2.equal(json.alias, alias, 'Alias for the URL');
    t2.equal(json.clicks, 0, 'The number of clicks on the URL');
    t2.equal(json.customAlias, true, 'This field will return true if the user sets the custom alias');
    t2.equal(json.userId, user._id.toString(), 'The user ID of the user who created the URL');

    t2.end();
    await checkForCallTearDown();
  });

  test('Fail: create a new url with custom Alias that already exists', async (t3) => {
    logger.info('t3: Fail: create a new url with custom Alias that already exists');

    const loginRes = await loginUser();
    t3.equal(loginRes.statusCode, 200);

    const { idToken } = loginRes.json() as LoginResponseDto;

    const longUrl = 'https://www.google.com';
    const alias = 'google';

    const response = await fastify.inject({
      method: 'POST',
      url: '/url',
      headers: {
        token: idToken
      },
      payload: {
        url: longUrl,
        customAlias: alias
      }
    });

    t3.equal(response.statusCode, 409);

    const json = response.json();

    t3.equal(json.message, 'Alias already exists');

    t3.end();
    await checkForCallTearDown();
  });

  test('Fail: create a new url with invalid url', async (t4) => {
    logger.info('t4: Fail: create a new url with invalid url');

    const loginRes = await loginUser();
    t4.equal(loginRes.statusCode, 200);

    const { idToken } = loginRes.json() as LoginResponseDto;

    const longUrl = 'google';

    const response = await fastify.inject({
      method: 'POST',
      url: '/url',
      headers: {
        token: idToken
      },
      payload: {
        url: longUrl
      }
    });

    t4.equal(response.statusCode, 400);

    const json = response.json();

    t4.equal(json.message, 'url: must match pattern "^(https?://)"');

    t4.end();
    await checkForCallTearDown();
  });

  test('Fail: create a new url with invalid token', async (t5) => {
    logger.info('t5: Fail: create a new url with invalid token');

    const longUrl = 'https://www.google.com';

    const response = await fastify.inject({
      method: 'POST',
      url: '/url',
      headers: {
        token: 'invalidtoken'
      },
      payload: {
        url: longUrl
      }
    });

    t5.equal(response.statusCode, 401);

    const json = response.json();

    t5.equal(json.message, 'Unauthorized: Invalid Jwt Token');

    t5.end();
    await checkForCallTearDown();
  });

  test('Fail: create a new url with no token', async (t6) => {
    logger.info('t6: Fail: create a new url with no token');

    const longUrl = 'https://www.google.com';

    const response = await fastify.inject({
      method: 'POST',
      url: '/url',
      payload: {
        url: longUrl
      }
    });

    t6.equal(response.statusCode, 401);

    const json = response.json();

    t6.equal(json.message, 'Unauthorized: Invalid Jwt Token');

    t6.end();
    await checkForCallTearDown();
  });
});

test('URL ROUTER `/:alias`: Process Url', async () => {
  const testsCount = 2;
  let testsDone = 0;

  const callTearDown = async () => {
    await checkForTearDown();
  };

  const checkForCallTearDown = async () => {
    testsDone += 1;
    if (testsDone === testsCount) {
      await callTearDown();
    }
  };

  test('Success: process a short url', async (t1) => {
    logger.info('t1: Success: process a short url');

    const loginRes = await loginUser();
    t1.equal(loginRes.statusCode, 200);

    const { idToken } = loginRes.json() as LoginResponseDto;

    const longUrl = 'https://www.google.com';
    const alias = 'googletest';

    const response = await fastify.inject({
      method: 'POST',
      url: '/url',
      headers: {
        token: idToken
      },
      payload: {
        url: longUrl,
        customAlias: alias
      }
    });

    t1.equal(response.statusCode, 201);

    const processResponse = await fastify.inject({
      method: 'GET',
      url: `/${alias}`
    });

    t1.equal(processResponse.statusCode, 302, 'The status code should be 302');

    t1.end();
    await checkForCallTearDown();
  });

  test('Fail: process a short url with invalid alias', async (t2) => {
    logger.info('t2: Fail: process a short url with invalid alias');

    const processResponse = await fastify.inject({
      method: 'GET',
      url: '/invalidalias'
    });

    t2.equal(processResponse.statusCode, 404, 'The status code should be 404');

    const json = processResponse.json();

    t2.equal(json.message, 'URL not found');

    t2.end();
    await checkForCallTearDown();
  });
});
